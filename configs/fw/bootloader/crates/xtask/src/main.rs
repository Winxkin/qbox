use std::{fs::File, io::Write};

use thiserror::Error;

#[derive(Clone, Copy, Debug)]
enum Command {
    Cargo,
    Objdump,
    #[cfg(target_os = "macos")]
    Brew,
}

#[cfg(target_os = "macos")]
macro_rules! binutils_prefix {
    ($cmd:literal) => {
        format_args!(
            "{}/bin/{}",
            Command::Brew.run_capture_out("--prefix binutils").unwrap(),
            $cmd
        )
    };
}

#[cfg(not(target_os = "macos"))]
macro_rules! binutils_prefix {
    ($cmd:literal) => {
        $cmd
    };
}

impl std::fmt::Display for Command {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match *self {
            Command::Cargo => f.write_str("cargo"),
            Command::Objdump => f.write_fmt(binutils_prefix!("objdump")),
            #[cfg(target_os = "macos")]
            Command::Brew => f.write_str("brew"),
        }
    }
}

impl From<Command> for TaskError {
    fn from(value: Command) -> Self {
        TaskError::Command(value.to_string())
    }
}

impl Command {
    fn run(self, args: &str) -> Result<(), TaskError> {
        println!("{} {}", self, args);
        let mut cmd = std::process::Command::new(self.to_string());
        match cmd.args(args.trim().split(' ')).status()?.success() {
            true => Ok(()),
            false => Err(self.into()),
        }
    }

    fn run_capture_out(self, args: &str) -> Result<String, TaskError> {
        println!("{} {}", self, args);

        let mut cmd = std::process::Command::new(self.to_string());
        let output = cmd.args(args.trim().split(' ')).output()?;
        let stdout = String::from_utf8_lossy(&output.stdout).to_string();
        Ok(stdout.trim().into())
    }
}

#[derive(Error, Debug)]
enum TaskError {
    #[error(transparent)]
    Io(#[from] std::io::Error),
    #[error("xtask failed")]
    Command(String),
}

fn build() -> Result<(), TaskError> {
    Command::Cargo.run("build --bin bootloader --config crates/bootloader/.cargo/config.toml")
}

fn objdump() -> Result<(), TaskError> {
    build()?;
    Command::Objdump.run("--disassemble --demangle --section .text target/aarch64/debug/bootloader")
}

fn objdump_out_to_lua(objdump_out: String) -> String {
    let mut ret = String::from(
        r#"-- This file is automatically generated by `cargo xtask lua`.
-- It is not intended for manual editing.
_bootloader_aarch64 = {
"#,
    );

    for line in objdump_out.lines().skip(4).filter(|line| !line.is_empty()) {
        if line.starts_with('<') {
            // Comment out labels
            ret.push_str(&format!("    -- {}\n", line));
        } else {
            // Get the hex value and the instruction to use as a comment
            let line = line.trim().split_once(' ');
            if let Some((hex, comment)) = line {
                let hex = match hex {
                    "00080000" => "_KERNEL64_LOAD_ADDR".to_string(),
                    "08000000" => "_DTB_LOAD_ADDR".to_string(),
                    _ => format!("0x{}", hex),
                };
                ret.push_str(&format!("    {}, -- {}\n", hex, comment));
            }
        }
    }

    ret.push_str("}\n");
    ret
}

fn lua() -> Result<(), TaskError> {
    build()?;
    let objdump_out = Command::Objdump.run_capture_out(
        "--disassemble --no-address --demangle --section .text target/aarch64/debug/bootloader",
    )?;
    let lua = objdump_out_to_lua(objdump_out);
    let mut lua_file = File::create("target/arm64_bootloader.lua")?;
    lua_file.write_fmt(format_args!("{}", lua))?;
    Ok(())
}

fn main() -> Result<(), TaskError> {
    let cmd = clap::Command::new("xtask")
        .subcommand(clap::Command::new("build").about("builds the bootloader"))
        .subcommand(
            clap::Command::new("objdump")
                .about("display information about the bootloader object file"),
        )
        .subcommand(clap::Command::new("lua").about("generates a LUA version of the bootloader"));

    let matches = cmd.get_matches();

    match matches.subcommand() {
        Some(("build", _)) => build()?,
        Some(("objdump", _)) => objdump()?,
        Some(("lua", _)) => lua()?,
        Some((subcommand, _)) => {
            return Err(TaskError::Command(format!(
                "Unknown subcommand {}",
                subcommand
            )))
        }
        None => return Err(TaskError::Command("Usage: cargo xtask --help".into())),
    }

    Ok(())
}
